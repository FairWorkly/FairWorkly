# Error Handling Architecture

This document provides a comprehensive overview of FairWorkly's error handling architecture and how different error mechanisms work together.

## Architecture Overview

FairWorkly implements **three layers of error handling**, each serving a distinct purpose while working together cohesively:

```txt
+------------------------------------------------------------------+
|                    1. Result<T> Pattern                            |
|              (Foundation / Generic Framework)                      |
|   Purpose: Unified return value wrapper for all Application       |
|            layer Handlers, using Of{code} factory methods         |
+------------------------------------------------------------------+
                              ^
                              |
                +-------------+-------------+
                |                           |
+---------------v-----------+   +-----------v--------------------+
| 2. GlobalExceptionHandler |   | 3. Business-Specific Errors    |
|   (Global Exception       |   |  - RosterIssue (compliance)    |
|    Catcher)               |   |  - ParseIssue (Excel parsing)  |
|                           |   |                                |
| Purpose: Catch exceptions |   | Purpose: Return business data, |
| that escape Result        |   | not errors -- carried inside   |
| wrapper (database errors, |   | Result<T>.Of200() responses    |
| domain exceptions)        |   |                                |
+---------------------------+   +--------------------------------+
```

---

## 1. Result\<T\> Pattern -- Foundation Framework

### Purpose

Unified return value for all Handler return types. Every MediatR Handler returns `Result<T>` with an HTTP status code baked in.

### What It Handles

- 200/201/204 -- Success with data, creation, or no content
- 400 -- Input validation failure (auto-generated by ValidationBehavior)
- 401 -- Authentication failure
- 403 -- Authorization failure
- 404 -- Resource not found
- 409 -- Conflict
- 422 -- Business processing error (with optional structured errors)
- 500 -- Anticipated infrastructure failure

### Implementation

**File Locations:**

- `src/FairWorkly.Domain/Common/Result/Result.cs` -- Main Result\<T\> class with Of{code} factory methods
- `src/FairWorkly.Domain/Common/Result/IResultBase.cs` -- Marker interface for ValidationBehavior
- `src/FairWorkly.Domain/Common/Result/Validation400Error.cs` -- 400 error structure
- `src/FairWorkly.Domain/Payroll/Errors/Csv422Error.cs` -- 422 CSV error structure

**Key Properties:**

```csharp
public class Result<T> : IResultBase
{
    public int Code { get; }                // HTTP status code (e.g., 200, 404, 422)
    public bool IsSuccess => Code is >= 200 and < 300;
    public T? Value { get; }                // Success DTO (only meaningful when IsSuccess)
    public string? Message { get; }         // Human-readable message for frontend
    public object? Errors { get; }          // Structured error list (400, 422 only)
}
```

**Factory Methods:**

| Method                               | Status | When to Use                                            |
| ------------------------------------ | ------ | ------------------------------------------------------ |
| `Of200(msg, value)`                  | 200    | Query/operation succeeded                              |
| `Of201(msg, value)`                  | 201    | Resource created                                       |
| `Of204()`                            | 204    | No content (delete, logout) -- use with `Result<Unit>` |
| `Of400(errors)`                      | 400    | **ValidationBehavior only** -- Handlers never call this |
| `Of401()` / `Of401(msg)`             | 401    | Unauthorized                                           |
| `Of403()` / `Of403(msg)`             | 403    | Forbidden                                              |
| `Of404()` / `Of404(msg)`             | 404    | Not found                                              |
| `Of409()` / `Of409(msg)`             | 409    | Conflict                                               |
| `Of422(msg)` / `Of422(msg, errors)`  | 422    | Business processing error                              |
| `Of500(msg)`                         | 500    | Anticipated infrastructure failure                     |

### Example Usage

**Handler:**

```csharp
public class LoginCommandHandler : IRequestHandler<LoginCommand, Result<LoginResponse>>
{
    public async Task<Result<LoginResponse>> Handle(...)
    {
        var user = await userRepository.GetByEmailAsync(email, cancellationToken);

        if (user == null || !passwordHasher.Verify(request.Password, user.PasswordHash))
        {
            return Result<LoginResponse>.Of401("Invalid email or password.");
        }

        if (!user.IsActive)
        {
            return Result<LoginResponse>.Of403("Account is disabled.");
        }

        return Result<LoginResponse>.Of200("Login successful", new LoginResponse
        {
            AccessToken = accessToken,
            User = userDto
        });
    }
}
```

**Controller:**

```csharp
[Route("api/[controller]")]
public class AuthController : BaseApiController
{
    [HttpPost("login")]
    public async Task<IActionResult> Login([FromBody] LoginCommand command)
    {
        var result = await _mediator.Send(command);
        return RespondResult(result);  // One line -- BaseApiController handles all formatting
    }
}
```

### BaseApiController -- Unified Response Mapping

All controllers inherit `BaseApiController`. The `RespondResult` method maps any `Result<T>` to the correct HTTP response with a unified JSON format:

**File:** `src/FairWorkly.API/Controllers/BaseApiController.cs`

**Three response shapes:**

1. **2xx success**: `{ code, msg, data: { ...DTO } }` (204 returns no body)
2. **4xx/5xx with errors** (400, 422): `{ code, msg, data: { errors: [...] } }`
3. **4xx/5xx without errors** (401, 403, 404, 409, 500): `{ code, msg }`

```csharp
protected IActionResult RespondResult<T>(Result<T> result)
{
    if (result.IsSuccess)
    {
        if (result.Code == 204) return NoContent();
        return StatusCode(result.Code, new { code = result.Code, msg = result.Message, data = result.Value });
    }

    if (result.Errors != null)
        return StatusCode(result.Code, new { code = result.Code, msg = result.Message, data = new { errors = result.Errors } });

    return StatusCode(result.Code, new { code = result.Code, msg = result.Message });
}
```

Controllers don't handle errors, format messages, or check result types. Messages are set exclusively in the Handler's `Of{code}` methods.

### ValidationBehavior -- Automatic 400 Interception

FluentValidation errors are automatically intercepted **before the Handler executes** and converted to `Result<T>.Of400`:

**File:** `src/FairWorkly.Application/Common/Behaviors/ValidationBehavior.cs`

```csharp
public class ValidationBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TResponse : IResultBase
{
    public async Task<TResponse> Handle(...)
    {
        var failures = validationResults
            .Where(r => r.Errors.Any())
            .SelectMany(r => r.Errors)
            .ToList();

        if (failures.Any())
        {
            var errors = failures.Select(f => new Validation400Error
            {
                Field = f.PropertyName,
                Message = f.ErrorMessage,
            }).ToList();

            // Calls Result<T>.Of400 via reflection
            return (TResponse)of400Method.Invoke(null, new object[] { errors })!;
        }

        return await next();
    }
}
```

**Flow:**

```txt
Request comes in
   |
ValidationBehavior (FluentValidation check)
   | Failed -> Auto-returns Result<T>.Of400(errors) -- Handler never executes
   | Passed
Handler executes business logic
   |
Returns Result<T>.Of{code}(...)
   |
Controller: return RespondResult(result)
```

**400 is exclusively owned by ValidationBehavior.** Handlers should never call `Of400` directly.

---

## 2. GlobalExceptionHandler -- Safety Net

### Purpose

Catch exceptions that **escape the Result pattern** (unexpected bugs, database errors, domain invariant violations).

### File Location

`src/FairWorkly.API/ExceptionHandlers/GlobalExceptionHandler.cs`

### Exception Types Handled

| Exception Type                | HTTP Status        | Scenario                                              |
| ----------------------------- | ------------------ | ----------------------------------------------------- |
| `OperationCanceledException`  | -- (no response)   | Client disconnected                                   |
| `ValidationException`         | 400                | FluentValidation throws exception (legacy code path)  |
| `DomainException`             | 422                | Domain rule/invariant violation                       |
| **All other exceptions**      | 500                | `DbUpdateException`, `NullReferenceException`, etc.   |

Note: `NotFoundException` and `ForbiddenAccessException` were removed -- these cases are now handled exclusively via `Result<T>.Of404()` and `Result<T>.Of403()` in Handlers.

### Implementation

```csharp
public class GlobalExceptionHandler : IExceptionHandler
{
    public async ValueTask<bool> TryHandleAsync(
        HttpContext httpContext, Exception exception, CancellationToken cancellationToken)
    {
        // Client disconnected -- no response needed
        if (exception is OperationCanceledException)
        {
            _logger.LogInformation("Request was cancelled (client disconnected)");
            return true;
        }

        var (statusCode, title, detail, extensions) = exception switch
        {
            ValidationException valEx => (400, "Validation Failed", ...),
            DomainException => (422, "Business Rule Violation", exception.Message, null),
            _ => (500, "Internal Server Error", "An error occurred while processing your request.", null),
        };

        // Returns RFC 7807 ProblemDetails (NOT the unified {code, msg, data} format)
        var problemDetails = new ProblemDetails { Status = statusCode, Title = title, Detail = detail, ... };
        await httpContext.Response.WriteAsJsonAsync(problemDetails, cancellationToken);
        return true;
    }
}
```

### Result\<T\> vs GlobalExceptionHandler

**Result\<T\>** -- The Handler anticipated the situation and made a conscious decision. Whether the outcome is good or bad, the Handler knows what happened, picks a status code, and writes a friendly message. A 404 not-found is a decision, a 422 bad-data is a decision, and a 500 S3-is-down is also a decision -- the Handler caught the exception and deliberately returned `Of500` with a friendly message.

**GlobalExceptionHandler** -- Nobody made a decision; the exception bubbled all the way up unhandled. This is for completely unexpected bugs (`NullReferenceException`, etc.) or Domain layer safety nets (`DomainException` for invalid entity state).

In one sentence: **Result\<T\> is the Handler saying "I know what happened", GlobalExceptionHandler is the system saying "something unexpected happened".**

---

## 3. Business-Specific Errors -- Data Carriers (Not Exceptions!)

### Critical Clarification

These are **NOT error handling mechanisms** -- they are **business data**! They are returned through `Result<T>.Of200()` as part of successful responses.

---

### A. RosterIssue -- Compliance Check Results

**Classification:** Domain entity, persisted in database

**Purpose:** Record **compliance issues** found during roster validation

**File Location:** `src/FairWorkly.Domain/Roster/Entities/RosterIssue.cs`

**Usage in Handler:**

```csharp
public class ValidateRosterHandler : IRequestHandler<ValidateRosterCommand, Result<ValidateRosterResponse>>
{
    public async Task<Result<ValidateRosterResponse>> Handle(...)
    {
        var roster = await rosterRepository.GetByIdWithShiftsAsync(...);

        if (roster == null)
            return Result<ValidateRosterResponse>.Of404("Roster not found");

        var issues = complianceEngine.EvaluateAll(roster.Shifts, validation.Id);

        var response = new ValidateRosterResponse
        {
            ValidationId = validation.Id,
            Status = failingIssues > 0 ? ValidationStatus.Failed : ValidationStatus.Passed,
            TotalIssues = issues.Count,
            Issues = issues.Select(i => new RosterIssueSummary { ... }).ToList()
        };

        // This is SUCCESS! Even with 50 compliance issues
        return Result<ValidateRosterResponse>.Of200("Roster compliance check completed", response);
    }
}
```

**Response to Frontend (200 OK):**

```json
{
  "code": 200,
  "msg": "Roster compliance check completed",
  "data": {
    "validationId": "guid",
    "status": "Failed",
    "totalIssues": 50,
    "issues": [
      {
        "checkType": "MinimumShiftDuration",
        "severity": "Error",
        "description": "Shift only 2.5 hours, minimum is 3 hours"
      }
    ]
  }
}
```

**Key Point:** This is a **successful Result**. Compliance issues are business data, not errors.

---

### B. ParseIssue -- Excel Parsing Results (Agent Service)

**Classification:** Pydantic data model returned by Python parser

**File Location:** `agent-service/agents/roster/services/roster_import/models.py`

The Agent Service collects parse issues (warnings + errors) during Excel processing and returns them as data in a successful response. The Backend Handler wraps this in `Result<T>.Of200()`.

---

### C. Csv422Error -- CSV Validation Errors (Payroll)

**Classification:** Standalone error class for structured 422 responses

**File Location:** `src/FairWorkly.Domain/Payroll/Errors/Csv422Error.cs`

```csharp
public class Csv422Error
{
    public int RowNumber { get; init; }
    public required string Field { get; init; }
    public required string Message { get; init; }
}
```

**Usage in CsvValidator:**

```csharp
var errors = new List<Csv422Error>
{
    new() { RowNumber = 5, Field = "Hourly Rate", Message = "Must be a positive number" },
};
return Result<ValidatePayrollDto>.Of422("CSV format validation failed", errors);
```

**Response to Frontend (422):**

```json
{
  "code": 422,
  "msg": "CSV format validation failed",
  "data": {
    "errors": [
      { "rowNumber": 5, "field": "Hourly Rate", "message": "Must be a positive number" }
    ]
  }
}
```

Custom error classes follow the naming convention `<Context><Code>Error` and are standalone -- no base class inheritance. Fields are determined by the API contract.

---

## How They Work Together

### Scenario 1: Roster Validation (Success with Issues)

```txt
User requests roster validation
   |
ValidateRosterHandler.Handle()
   |
Compliance engine checks -> Finds 50 compliance issues (RosterIssue entities)
   |
Result<ValidateRosterResponse>.Of200("Roster compliance check completed", response)
   |
Controller: return RespondResult(result)  -> 200 + all issues in data
   |
Frontend displays: Validation failed, 50 issues need fixing
```

---

### Scenario 2: Payroll CSV Validation (Processing Error with Details)

```txt
User uploads CSV
   |
ValidatePayrollHandler.Handle()
   |
CsvValidator finds field errors in multiple rows
   |
Result<ValidatePayrollDto>.Of422("CSV format validation failed", errors)
   |
Controller: return RespondResult(result)  -> 422 + errors array in data
```

---

### Scenario 3: Input Validation (Auto-Intercepted)

```txt
User submits request with missing required fields
   |
ValidationBehavior intercepts BEFORE Handler executes
   |
FluentValidation finds failures -> Result<T>.Of400(List<Validation400Error>)
   |
Controller: return RespondResult(result)  -> 400 + errors array in data
   |
Handler never runs
```

---

### Scenario 4: Infrastructure Failure (Anticipated)

```txt
Handler calls Agent Service -> HttpRequestException
   |
catch (OperationCanceledException) { throw; }  // Let cancellation propagate
catch (Exception ex)
{
    logger.LogError(ex, "Agent Service failed");
    return Result<RosterDto>.Of500("Failed to parse roster. Please try again.");
}
   |
Controller: return RespondResult(result)  -> 500 + friendly message
```

---

### Scenario 5: Database Constraint Violation (Unexpected)

```txt
Handler: rosterRepository.CreateAsync()
   |
EF Core: DbUpdateException (unique index violation)
   |
Exception escapes Handler (not anticipated)
   |
GlobalExceptionHandler catches it
   |
Returns 500 ProblemDetails (generic message, no internal details exposed)
```

---

## Summary Comparison Table

| Scenario                            | Mechanism         | Factory Method        | HTTP Status | JSON Format                      |
| ----------------------------------- | ----------------- | --------------------- | ----------- | -------------------------------- |
| Query/operation succeeded           | Result\<T\>       | `Of200(msg, dto)`     | 200         | `{ code, msg, data }`           |
| Resource created                    | Result\<T\>       | `Of201(msg, dto)`     | 201         | `{ code, msg, data }`           |
| No content (delete/logout)          | Result\<T\>       | `Of204()`             | 204         | No body                         |
| Input validation failed             | ValidationBehavior | `Of400(errors)`      | 400         | `{ code, msg, data: { errors } }` |
| Unauthorized                        | Result\<T\>       | `Of401(msg)`          | 401         | `{ code, msg }`                 |
| Forbidden                           | Result\<T\>       | `Of403(msg)`          | 403         | `{ code, msg }`                 |
| Not found                           | Result\<T\>       | `Of404(msg)`          | 404         | `{ code, msg }`                 |
| Conflict                            | Result\<T\>       | `Of409(msg)`          | 409         | `{ code, msg }`                 |
| Business processing error           | Result\<T\>       | `Of422(msg, errors)`  | 422         | `{ code, msg, data: { errors } }` |
| Infrastructure failure (anticipated) | Result\<T\>      | `Of500(msg)`          | 500         | `{ code, msg }`                 |
| Compliance issues found             | Business Data     | `Of200(msg, dto)`     | 200         | `{ code, msg, data: { issues } }` |
| Domain invariant violation          | GlobalHandler     | ProblemDetails        | 422         | RFC 7807                        |
| Database/unknown exception          | GlobalHandler     | ProblemDetails        | 500         | RFC 7807                        |

---

## Design Philosophy

1. **Result\<T\>** -- Predictable outcomes (success, validation, permissions, anticipated failures)
2. **Business Data** (RosterIssue/ParseIssue) -- Successful execution results, even when containing issues
3. **GlobalExceptionHandler** -- Safety net for unexpected system-level exceptions

### Key Distinctions

- **RosterIssue** = "I successfully checked your roster and found 50 issues" (200 OK)
- **Of422** = "Your CSV has errors I can describe in detail" (422 with errors list)
- **Of500** = "Agent Service is down, I caught it and have a friendly message" (500)
- **GlobalException** = "Something completely unexpected happened" (500 ProblemDetails)

---

## Best Practices

### When to Use Result\<T\>

**DO use Result\<T\>** for:

- All Handler return values -- every Handler returns `Result<T>`
- Anticipated failures with friendly messages (404, 403, 422, 500)
- Infrastructure failures the Handler catches (Agent Service down, S3 error)

**DO NOT use Result\<T\>** for:

- Returning business data that includes issue lists -- use `Of200` with the issues as part of the DTO
- Input validation -- let ValidationBehavior + FluentValidation handle 400 automatically

### When to Use Business Data Models

**DO use RosterIssue/ParseIssue** when:

- The operation succeeded but found problems in the data
- Issues are part of the expected output
- Frontend needs detailed issue information for display

### When to Throw Exceptions

**DO throw exceptions** for:

- Programming errors (null references, invalid state)
- Database errors (let EF Core throw, GlobalHandler will catch)
- Domain invariant violations (throw DomainException)

**DO NOT throw exceptions** for:

- Parsing errors in individual rows (collect as issues or Csv422Error)
- Compliance check violations (store as RosterIssue)
- Infrastructure failures the Handler can anticipate (use `Of500` instead)

### OperationCanceledException

Always re-throw `OperationCanceledException` before catching generic `Exception`:

```csharp
catch (OperationCanceledException) { throw; }
catch (Exception ex)
{
    logger.LogError(ex, "...");
    return Result<T>.Of500("...");
}
```

This ensures client disconnections propagate correctly instead of being swallowed as 500 errors.

---

## File References

### Core Result Pattern

- `src/FairWorkly.Domain/Common/Result/Result.cs` -- Result\<T\> with all Of{code} factory methods
- `src/FairWorkly.Domain/Common/Result/IResultBase.cs` -- Marker interface for ValidationBehavior
- `src/FairWorkly.Domain/Common/Result/Validation400Error.cs` -- 400 error structure (Field, Message)
- `src/FairWorkly.Application/Common/Behaviors/ValidationBehavior.cs` -- Auto 400 interception

### Controller Layer

- `src/FairWorkly.API/Controllers/BaseApiController.cs` -- RespondResult unified response mapping

### Exception Handling

- `src/FairWorkly.API/ExceptionHandlers/GlobalExceptionHandler.cs` -- Global exception catcher
- `src/FairWorkly.Domain/Exceptions/DomainException.cs` -- Domain invariant violation

### Error Models

- `src/FairWorkly.Domain/Payroll/Errors/Csv422Error.cs` -- Payroll CSV error structure
- `src/FairWorkly.Domain/Roster/Entities/RosterIssue.cs` -- Compliance issue entity

### Example Implementations

- `src/FairWorkly.Application/Auth/Features/Login/LoginCommandHandler.cs` -- Auth Handler example
- `src/FairWorkly.Application/Payroll/Features/ValidatePayroll/ValidatePayrollHandler.cs` -- Payroll Handler example
- `src/FairWorkly.API/Controllers/Payroll/PayrollController.cs` -- Thin controller example

---

## Additional Documentation

- See `docs/guides/backend/result-pattern.md` for detailed Result\<T\> usage guide with examples
- See `backend/CLAUDE.md` for backend architecture overview
